---
layout: post
title:  "알고리즘2 - 퀵 정렬과 기초 정렬 문제 풀어보기"
subtitle:   "algorithm-2"
categories: cs
tags: algorithm
comments: true
---  

- 퀵 정렬과, 기초 정렬 문제 풀이에 대한 글입니다.  

---  

# 5. 퀵 정렬(Quick Sort)의 시간 복잡도와 작동 원리  
- 앞의 선택, 버블, 삽입정렬 모두 시간 복잡도 O(N^2)  
  - 하지만, 데이터 수가 많아지면 상당히 비효율적  
    (데이터가 10만 개만 넘어가도 일반적인 상황에서 사용하기 매우 어려움)  
  - 더 빠른 알고리즘 필요  
  
- 퀵 정렬  
  - `분할정복` 알고리즘 사용  
  - 시간복잡도: `O(NlogN)`  
    - cf) NlogN은 상당히 효율적인 것! (거의 상수라고 봐도 무방)  
    
      ```  
      2^10: 약 1000  
      2^20: 약 1000000  
      
      밑이 2인 log: 지수가 2^20일 때, 20밖에 안됨!  
      ```  
       
- Idea:  
  `특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누면 어떨까?`  
  
  - 퀵 정렬에는 `기준 값` (혹은 `피벗(Pivot)`)이 있음.  
    - 그 특정값을 기준으로 큰 숫자와 작은 숫자로 나눈다. (분할)  
    - 보통 첫 번째 원소를 피벗 값으로 설정함.  
    
- ex1) `3 7 8 1 5 9 6 10 2 4` 정렬하기  

  - Process  
    - '분할'이 일어났을 때, 그 기준이 되는 값, 혹은 고정된 값을 []로 표시  
    - '피벗 값'을 ''로 표시  
    
  - '3' 7 8 1 5 9 6 10 2 4  
  - '3' 2 8 1 5 9 6 10 7 4  
  - '3' 2 1 8 5 9 6 10 7 4  // 엇갈림!  
  - 1 2 [3] 8 5 9 6 10 7 4  
  - '1' 2 [3] '8' 5 9 6 10 7 4  
  - [1] '2' [3] '8' 5 9 6 10 7 4  
  - [1] [2] [3] '8' 5 9 6 10 7 4  
  - [1] [2] [3] '8' 5 4 6 10 7 9  
  - [1] [2] [3] '8' 5 4 6 7 10 9  // 엇갈림!  
  - [1] [2] [3] '7' 5 4 6 [8] '10' 9 // 8의 좌측에서, 또 '엇갈림'  
  - [1] [2] [3] 6 5 4 7 [8] '10' 9  
  - ...  
  
  - 한 번 정렬을 수행했을 때, 그 값을 기준으로 왼쪽과 오른쪽이 나뉘어진다!  
  
  
- ex2) `1 2 3 4 5 6 7 8 9 10`  
  - if 선택정렬:  N^2: 대략 100  
  - if 퀵정렬: 5^2 + 5^2 = 50 (분할정복)  
    - 쪼개서 연산을 하고 나중에 합치면 결론적으로 연산의 수는 더 적다.  
    
    - `N*logN`에서  
      - N: 데이터의 수  
      - logN: 반씩 쪼개서 들어가기 때문에 절약되는 부분  
  
    - 백만개 정도도 어렵지 않게 수행할 수 있다!  
    
# 6. 퀵 정렬 (Quick Sort)의 구현 및 한계점 분석  

```  
#include <stdio.h>

int number= 10;
int data[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

void quickSort(int *data, int start, int end){
	if (start >= end) // 원소가 한 개인 경우 
	{
		return;
	}
	
	int key = start; // 키는 첫번째 원소
	int i = start + 1; // i: 왼쪽 출발 지점  
	int j = end; // j: 오른쪽 출발 지점   
	int temp; 
	
	while(i <= j){ // 엇갈릴 때까지 반복  
		while(data[i] <= data[key]) // 키 값보다 큰 값 만날 때까지  
		{
			i++;
		}
		while(data[j] >= data[key] && j > start) // 키 값보다 작은 값을 만날 때까지 
		{
			j--;
		}
		if (i>j) // 현재 엇갈린 상태면 키 값과 교체 
		{
			temp = data[j];
			data[j] = data[key];
			data[key] = temp;
		} else {
			temp = data[j];
			data[j] = data[i];
			data[i] = temp;
		}
	}
	// 재귀적 함수 이용 
	quickSort(data, start, j-1);
	quickSort(data, j+1, end);  
}


int main(void){
	quickSort(data, 0, number -1);
	for(int i=0; i<number; i++)
	{
		printf("%d ", data[i]);
	}
	return 0;
}   
```  
    
- 한계점  
  - 퀵정렬은 피벗값의 설정에 따라, `최악의 경우`에는 시간 복잡도가 `O(N^2)`가 나올 수 있다.  
    (평균 시간 복잡도는 O(NlogN))  
    
  - 흔히 알고리즘 대회에서 O(NlogN)을 요구하는 경우 퀵 정렬을 이용하면 틀리기도 함  
  
- ex) `1 2 3 4 5 6 7 8 9 10`  
  - '1' 2 3 4 5 6 7 8 9 10  
  - [1] '2' 3 4 5 6 7 8 9 10  
  - [1] [2] '3' 4 5 6 7 8 9 10  
  
  ... 이런 경우 분할 정복의 이점을 전혀 사용하지 못하고 반복적으로 O(N^2)만큼 수행하게 됨  
  - 이 경우는 오히려 `삽입 정렬`이 더 빠르다!  
  
  ```  
  '항상' A라는 정렬이 B라는 정렬보다 빠르다! 라는 식으로 구분하지 말 것.  
  ```  
    
- 내림차순~  

  ```  
  	while(i <= j){ 
		while(data[i] >= data[key]) // 이 부분  
		{
			i++;
		}
		while(data[j] <= data[key] && j > start) // 이 부분 
		{
			j--;
		}
  ```  
  
  - 두 부분만 바꾸면 내림차순으로 쉽게 바뀐다~  
   
