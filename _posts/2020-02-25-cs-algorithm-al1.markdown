---
layout: post
title:  "알고리즘1 - 선택정렬, 버블정렬, 삽입정렬"
subtitle:   "algorithm-1"
categories: cs
tags: algorithm
comments: true
---  

- 선택정렬, 버블정렬, 및 삽입정렬에 대한 글입니다.  

---  

# 1. 알고리즘의 개요와 실습 환경 구축  

- 알고리즘  
  - 알고리즘은 '문제를 해결하는 절차'이다.  
    - '입력', '출력', '유한성', '명백성', '효과성' 만족해야  
    - 수학적인 분석을 통해 알고리즘의 좋고 나쁨을 평가할 수 있다.  

  - 알고리즘은 '개발'의 전체 과정에 사용된다.  
  
  - 알고리즘은 프로그래머에게 피할 수 없는 운명이다.  
    - 알고리즘과 관련한 대회 및 기관: ex) ACM-ICPC, 구글 코드잼, 코드포스, 정보올림피아드 등  
    - 일반적 개발에서는 높은 난이도의 알고리즘은 거의 사용되지 않음  
    - 알고리즘 문제는 종합적인 개발 역량을 평가하기에 좋은 용도  
  
- DEV C++ 사용~  
 
# 2. 정렬 알고리즘의 개요와 `선택 정렬 (Selection Sort)`  
- 정렬: 알고리즘의 효율성 차이를 극명하게 보여줌  
  
- 다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하시오   
  `1 10 5 8 7 6 4 3 2 9`  

  - 선택정렬  
    `가장 작은 것을 선택해서 제일 앞으로 보내면 어떨까?`  
    
    - Process  
      
      ```  
      - 1부터 9까지의 수 중 가장 작은 수를 맨 앞으로 보내고 자리 바꿈. ( 이 경우 이미 1이 맨 앞)   
        → 1 | 10 5 8 7 6 4 3 2 9  
      - 10부터 9까지의 수 중 가장 작은 수를 두번째 앞으로 보내고 자리 바꿈.  
        → 1 2 | 5 8 7 6 4 3 10 9  
        ...
      ```  
      
    ```  
    #include <stdio.h>

    int main(void){
      int i, j, min, index, temp;
      int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

      for(i=0; i<10; i++)
      {
        min = 9999;
        for (j = i; j < 10; j++)
        {
          if(min > array[j])
          {
            min = array[j];
            index = j;
          }
        }
        temp = array[i];			// 일반적으로 이 세 줄을 
        array[i] = array[index];	// 합쳐서 일반적을 'swapping을 한다' 
        array[index] = temp;		// 라고 해주기도 함. 
      }

      for (i=0; i<10; j++)
      {
        printf("%d ", array[i]);
      }

      return 0;
    } 
    ```  
    
    > 결과  
      
      `1 2 3 4 5 6 7 8 9 10`   
    
- 선택 정렬의 시간 복잡도?  
  ![](https://latex.codecogs.com/gif.latex?O%28N%5E2%29)  
  
  - 10 + 9 + 8 + ... + 1  
    : 10 * (10 + 1) / 2 = 55  
    
    - 즉, 10개를 대상으로 55번의 비교 연산을 진행해야 된다는 말  
  
  - 알고리즘의 수행시간: `N * (N + 1) / 2`  
    - 특정한 알고리즘의 수행시간을 가장 간략하게 표현한 것이 Big-O 표기법이며,  
      해당 알고리즘의 시간복잡도 `O(N*N)`  
      
  - 선택정렬 알고리즘은 정렬 알고리즘 중에서 상당히 `비효율적`인 알고리즘 중의 하나!  
    - 데이터의 수가 조금만 커지더라도, N^2의 그래프를 떠올려 보았을 때,  
      연산횟수가 엄청나게 증가한다.  
  
# 3. 버블 정렬(Bubble Sort)    
- 선택정렬과 마찬가지로 직관적인 해결 방법  

- 버블정렬  
  `옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내면 어떨까?`  
  
  - 구현하기는 가장 쉬우나 정렬 알고리즘들 중 효율성은 가장 떨어지는 알고리즘  
  
  - Process  
    
    ```  
    - 1과 10을 비교해서 더 작은 것을 앞으로 옮긴다.  
      1 | 10 5 8 7 6 4 3 2 9   
    - 10과 5를 비교해서 더 작은 것을 앞으로 옮긴다.  
      1 5 | 10 8 7 6 4 3 2 9   
    - 10과 8을 비교해서 더 작은 것을 앞으로 옮긴다.  
      1 5 8 | 10 7 6 4 3 2 9   
      ...  
      
      - 한 번의 반복이 끝나면  
        1 5 8 7 6 4 3 2 9 10 
        - 즉, 버블 정렬은 가장 큰 값이 맨 뒤로 보내지는 방식이라고 할 수 있다.  
    
    - ... 이를 정렬이 완료될 때까지 반복  
    ```  
    
    ```  
    #include <stdio.h>

    int main(void){
      int i, j, temp; 
      int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
      for (i = 0; i < 10; i++)
      {
        for (j = 0; j < 9 - i; j++) // 9-i: 뒤에서부터 집합의 크기를 하나씩 감소시키니까  
        {
          if(array[j] > array[j+1])
          {
            temp = array[j];
            array[j] = array[j+1];
            array[j+1] = temp;
          } 
        }	
      }
      for(i=0; i<10; i++)
      {
        printf("%d ", array[i]);
      }
      return 0;
    }
    ```  
    
    > 결과  
      `1 2 3 4 5 6 7 8 9 10`  
      
- 버블 정렬의 시간 복잡도?  
  ![](https://latex.codecogs.com/gif.latex?O%28N%5E2%29)  
  
  - 비교연산의 횟수:  
    10 + 9 + 8 + 7 + ... + 1  
    - N * (N+1) / 2  
    - O(N*N) (선택정렬과 동일한 시간 복잡도)  
    
    - 하지만, 실제로 실행을 해보면 선택정렬보다 훨씬 느리게 작동  
  
- 버블정렬: 일반적으로 정렬 알고리즘 중 가장 느리다!   

# 4. 삽입 정렬(Insertion Sort)  
- 다른 정렬 방식들은 위치를 바꾸는 방식이었다면,  
  삽입 정렬은 `필요할 때만` 위치를 바꾼다.  
  
- 선택정렬, 버블정렬과 마찬가지로 시간 복잡도는 O(N^2) (비효율)  
  - 하지만, 이 셋 중에는 가장 강력한 알고리즘이라 할 수 있음  
  
- `각 숫자를 적절한 위치에 삽입하면 어떨까?`  
  (앞에 있는 원소들이 '이미 정렬이 되어있다'는 `가정`을 함.)  

- Process   

  ```  
  1, 10, 5, 8, 7, 6, 4, 3, 2, 9 
  
  - 1은 이미 맨 앞에 있기 때문에, 그대로 유지  
    1, 10, 5, 8, 7, 6, 4, 3, 2, 9  
  - 10은 10의 앞을 봤을 때 1의 앞 혹은 뒤에 들어갈 수 있는데 (_ 1 _), 정렬 순서상 1의 뒤에 있는 것이 옳음.  
    그런데 이미 1의 뒤에 있으므로 그대로 놔둔다  
    1, 10, 5, 8, 7, 6, 4, 3, 2, 9  
  - 5는 5의 앞을 봤을 때 총 세 군데에 들어갈 수 있는데 (_ 1 _ 10 _), 1과 10 사이에 들어가는 것이 옳음  
    1, 5, 10, 8, 7, 6, 4, 3, 2, 9  
  - ...  
  
  - 이를 반복하면 결국 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 으로 정렬이 이루어지게 됨  
  ```  
  
  ```  
  #include <stdio.h>

  int main(void)
  {
    int i, j, temp;	
    int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
    for(i = 0; i < 9; i++)
    {
      j = i;
      while(array[j] > array[j+1])
      {
        temp = array[j];
        array[j] = array[j+1];
        array[j+1] = temp;
        j--;
      }
    }
    for (i=0; i<10; i++)
    {
      printf("%d ", array[i]);
    }
    return 0;
  }   
  ```  
  
- 역시 시간 복잡도: O(N*N)  

- cf) 거의 정렬이 다 된 상태에서 다시 정렬을 하려고 한다면?  
  → 삽입 정렬이 굉장히 빠르다!  
    - ex) 2, 3, 4, 5, 6, 7, 8, 9 10, 1  
 
---   
  
#### 요약  

|-|시간복잡도|속도|  
|-|---------|----|  
|선택정렬|O(N^2)|3|  
|버블정렬|O(N^2)|2|  
|삽입정렬|O(N^2)|1|  

- 세 정렬은 모두 시간 복잡도 O(N^2)  
- 하지만 그 중에서도 삽입정렬이 가장 빠름  
- 삽입정렬은 특히나, 정렬이 어느 정도 이루어져 있을 때 굉장히 효율적  

---   

#### Reference  
- 나동빈님 실전 알고리즘 강좌  


  


 
