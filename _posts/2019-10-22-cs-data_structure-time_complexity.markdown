---

layout: post
title:  "시간복잡도란?"
subtitle:   "data_structure-time_complexity"
categories: cs
tags: data_structure
comments: true

---  

- 알고리즘의 시간복잡도 전반에 관해 정리한 글입니다.  

---  
## Intro  

### 알고리즘이란?  
알고리즘이란 주어진 문제를 유한한 시간 내에 해결하기 위한 절차를 기술하는 것이라 말할 수 있습니다. 이전 포스팅의 예를 들어, 
대학원 생 10명의 학번이 오름차순으로 정렬되어 있다면, 특정 학생을 검색하기 위한 방법들인 선형 탐색 및 이진 탐색을 `알고리즘`이라 할 수 있습니다.   

### 알고리즘의 효율성 분석?  
자료구조의 효율성은 해당 `자료구조에 대해 수행되는 연산 수행 시간`으로 측정하는데, 
알고리즘의 효율성 분석 방식은 자료구조의 효율성 분석 방식과 동일합니다. 요컨대, 
알고리즘의 효율성 분석은 해당 `알고리즘에 대해 수행되는 연산 수행 시간`으로 이해하면 됩니다.  

알고리즘의 효율성 분석은 공간적 효율성과 시간적 효율성 두 측면에서 분석해볼 수 있습니다. 
하지만 시간이 공간보다 비싸기에 일반적으로 `시간적 효율성`을 공간적 효율성보다 훨씬 강조하게 됩니다. 

---  
## 시간 복잡도 분석?  

### 알고리즘의 시간 복잡도 분석? (Time Complexity Analysis)  
그렇다면 어떻게 알고리즘의 시간 복잡도를 분석해야 할까요? 

먼저, 프로그램을 실제로 컴퓨터에서 실행시켜 보고 실행 완료까지 얼마나 
시간이 소요되었는지를 측정해서 시간 복잡도를 측정해볼 수 있겠습니다. 하지만, 하드웨어 및 소프트웨어 환경에 따라 수행시간은 얼마든지 
달라질 수 있기 때문에 이 방법으로 객관적인 시간 복잡도 분석을 하기에는 한계가 있습니다.  

따라서 `실행 환경과 무관하게 개략적으로 시간 복잡도를 측정` 할 수 있어야 합니다. 
이는 '`입력 크기`에 따라서 `기본 연산`이 몇 번 수행되는가'를 측정하는 방식으로 달성됩니다. 
여기서 기본 연산이란 알고리즘을 수행하는 데에 있어서 가장 핵심적인 역할을 담당하는 연산을 이야기하는 것으로 
비교 연산, 산술 연산, 대입 연산, 출력 연산 등을 예로 들 수 있습니다.  

### 시간 복잡도 분석의 방법?  
시간 복잡도 분석에는 네 가지 방법이 있습니다. 
```  
1. 최악의 경우(Worst case) 분석  
2. 최선의 경우(Best case) 분석  
3. 평균의 경우(Average case) 분석  
4. 모든 경우의(Every case) 분석
```

#### 1. 최악의 경우 분석  
입력(입력 크기 + 입력 값의 내용)에 대해 기본 연산이 수행되는 횟수가 `최대(최악)`인 경우를 선택하는 분석이며, 
`W(n)`으로 표기합니다. (n: 입력의 크기)  
```  
# Example1)  
  def linear_search(target, dataset):  
    for i in range(len(dataset)):  
      if dataset[i] == target:  
        return i;  
    return 'Not found'  
  dataset = [10,30,20,40,50,45,60,70,80,90]  
  result = linear_search(95, dataset)  
```  
이 경우 입력의 크기는 10이며, 기본 연산은 `dataset[i] == target`입니다. 타겟값이 90일 경우 기본 연산이 10번 수행되므로 
W(n) = n이라 할 수 있습니다.  

#### 2. 최선의 경우 분석  
입력(입력 크기 + 입력 값의 내용)에 대해 기본 연산이 수행되는 횟수가 `최소(최선)`인 경우를 선택하는 분석이며, 
`B(n)`으로 표기합니다. (n: 입력의 크기)  위 예에서 타겟값이 10일 경우 입력 크기와 상관없이 기본 연산이 한 번만 수행되므로 
B(n) = 1이라 할 수 있습니다. 그런데, 어떤 알고리즘을 만들더라도 최선의 경우를 갖고 분석을 하면 안됩니다.  

#### 3. 평균의 경우 분석  
입력(입력 크기 + 입력 값의 내용)에 대해 입력값의 확률 분포를 가정한 후, 모든 입력 값에 대해 기본 연산이 수행되는 횟수의 평균을 계산하는 
방식이며 `A(n)`으로 표기합니다. 위의 예에서 dataset의 값들은 모두 한 개씩 존재하기 때문에 입력 값들에 대해서 균등분포 (uniform distribution)을 
가정할 수 있습니다. 일반적으로는 이처럼 균등분포를 가정하며, Average case analysis에는 항상 가정에 대한 언급이 있어야만 합니다.  

균등분포의 경우에서, n개의 입력값에 대해 각 값이 존재할 확률은 $$\frac{1}{n}$$입니다. 
이 때 k번째에 있는 값을 검색하기 위해서는 k번을 검색해야 합니다. 
그렇다면 평균의 경우 시간복잡도를 다음과 같이 나타내 볼 수 있습니다.  
A(n) = $$\frac{\sum_{i=1}^{n}{i}}{n}$$ = $$\frac{1}{n}$$$$\frac{n(n+1)}{2}$$ = $$\frac{n+1}{2}$$  
따라서 평균의 경우 시간 복잡도는 (A(n)) 이 경우 $$\frac{n+1}{2}$$라 할 수 있습니다.  

#### 4. 모든 경우의 경우 분석  
이 분석은 입력 값의 내용과 무관하게 복잡도가 항상 일정한 경우에만 사용 가능합니다. 즉, 
모든 경우의 분석이 가능하다면 최악, 최선, 평균의 경우의 시간 복잡도가 모두 동일합니다. 모든 경우의 시간 복잡도는 `T(n)`으로 표기하며 
다음과 같은 예를 들 수 있습니다.  
```  
def sum(dataset):  
  result = 0;  
  for i in dataset:  
    result += i
  return result  
  
  dataset = [10,30,20,40,50,45,60,70,80,90]  
  result = sum(dataset)  
```
파이썬 리스트 내의 값들이 어떤 값인가에 상관없이 항상 기본 연산이 입력의 크기와 같은 10번만 수행됩니다. T(n)=n으로 나타낼 수 있겠습니다.  

추가적으로 기본 연산에 대해 입력 값의 내용과 무관할 경우에는 모든 경우의 분석을 사용하고, 그렇지 않을 경우 최악의 경우나 평균의 경우 분석을 
사용하는 것이 좋습니다. 평균 경우 분석 사용이 어렵다면 최악의 경우 분석 방법을 사용하도록 합니다.  

---  
## 알고리즘의 점근표기법  
앞서 시간 복잡도 분석의 네 가지 방법에 대해 서술해보았습니다. 그렇다면 동일한 문제를 두고 두 가지 알고리즘을 두고 두 알고리즘 중 
어떤 알고리즘이 더 효율적이라고 말할 수 있을까요? 예를 들어, 시간 복잡도가 100n인 알고리즘과 0.01$$n^2$$ + 20n인 알고리즘 중 어떤 알고리즘이 
더 효율적이라고 할 수 있을까요? 이 문제에 답하기 위해 
`알고리즘의 점근적 복잡도(Asymptotic Complexity)`와 `점근표기법(Asymptotic Notation)`이라는 내용이 등장합니다. 

### 알고리즘의 점근적 복잡도 (Asymptotic Complexity)와 점근표기법(Asymptotic Notation)
알고리즘의 `점근적 복잡도`는 간단히 말하면 입력 크기 n의 값이 무한히 클 경우의 시간 복잡도를 의미합니다. 입력 값의 크기가 무한히 
큰 경우 차수가 가장 큰 항이 특정 알고리즘의 시간 복잡도에 가장 큰 영향을 미치고 다른 항들은 상대적으로 무시될 수 있습니다. 
상수 계수와 중요하지 않은 항들을 제외하고 가장 영향력이 큰 항만 남겨 복잡도를 표기하는 방법을 알고리즘의 `점근표기법`이라고 합니다. 점근적 복잡도 함수의 
증가율이라고 이해할 수도 있습니다.  

점근 표기법에도 여러 종류가 있으며 오늘은 세 가지(Big-Oh, Omega, Theata 표기법)에 대해 다루어보도록 하겠습니다. 
다음은 각 복잡도 함수의 증가율 그래프입니다.  
![](https://mblogthumb-phinf.pstatic.net/MjAxODAzMjJfMTEg/MDAxNTIxNjQ2MzQyNDU2.R9Jree8ADnKVdi6vTSmj41PiovwR7ajSX777z5dG3wsg.fWLV9kg6j32aNyq4crcakf9nK3AgZFeQ0csghPx77R0g.PNG.demonic3540/image.png?type=w800)  

### 점근표기법의 종류  

#### O(Big-Oh) 표기법
입력크기 n에 대해 n>$$n_0$$, f(n)$$\leq$$c$$\cdot$$g(n)이 성립하는 `임의의` 양수 c와 $$n_0$$이 존재하면 , `f(n)= O(g(n))`입니다. 
특정 알고리즘의 시간 복잡도가 f(n)이라고 했을 때, $$n_0$$과 같거나 큰 모든 n에 대해 f(n)이 c$$\cdot$$g(n)보다 크지 않다는 것을 의미하고, 
f(n)이 아무리 나빠도 c$$\cdot$$g(n)보다 나빠지지는 않는다로 이해하면 될 것 같습니다. 이 때 
g(n)을 f(n)의 상한이라고 합니다. 이 때 g(n)은 복잡도 함수입니다.  
- Example. f(n) = $$2n^2 + 3n + 5 $$ → f(n) = $$O(n^2)$$  
보통 Big-Oh 표기법을 가장 많이 사용한다고 합니다.  

![](https://cdn.kastatic.org/ka-perseus-images/501211c02f4c6765f60f23842450e1151cfd9c89.png_)  

#### Ω(Omega) 표기법  
입력크기 n에 대해 n>$$n_0$$, f(n)$$\geq$$c$$\cdot$$g(n)이 성립하는 양수 c와 $$n_0$$이 존재하면, `f(n)= Ω(g(n))`입니다. 
특정 알고리즘의 시간 복잡도가 f(n)이라고 했을 때, $$n_0$$과 같거나 큰 모든 n에 대해 f(n)이 c$$\cdot$$g(n)보다 작지 않다는 것을 의미하고, 
f(n)이 아무리 좋아도 c$$\cdot$$g(n)보다 좋아질 수는 없다로 이해하면 될 것 같습니다. 이 때 
g(n)을 f(n)의 하한이라고 합니다. 어떤 함수 f(n)이 Ω(g(n))임을 보이는 데에 있어서 c와 $$n_0$$이 한 가지 값만 있는 것이 아니므로 적당히 
작은 값들을 택하면 됩니다. 

![](https://ko.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-big-omega-notation)  

#### Θ(Theta) 표기법  
모든 n>$$n_0$$에 대해서 $$c_1$$$$\cdot$$g(n) $$\geq$$ f(n) $$\geq$$ $$c_2$$$$\cdot$$g(n)이 성립하는 양의 상수 $$c_1, c_2, n_0$$이 존재하면, 
f(n) = Θ(g(n))입니다. Θ 표기법은 특정 알고리즘의 시간 복잡도의 O표기와 Ω표기가 동일한 경우에 사용하며, 모든 경우를 분석 할 때에는 
O표기법보다 Θ 표기법을 많이 사용합니다.  
- Example. f(n) = $$2n^2 + 3n + 5 $$ → f(n) = Θ($$n^2$$) 이 때, Θ($$n^2$$)의 의미는 무한히 큰 입력 크기 n에 대해 
$$2n^2 + 3n + 5 $$와 $$n^2$$의 증가율이 유사함을 의미합니다. 

#### Reference  
[Big-O (빅 오) 표기법](https://ko.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation)
[[자료구조] 빅 오 표기법](https://m.blog.naver.com/demonic3540/221234387783)
